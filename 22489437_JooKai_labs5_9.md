# Lab Report 5 - 9

*Author*: Joo Kai Tay (22489437)

## Lab 5: Networking

### Section 1: Configure inbound IP on VM
1. Configure the network adapted in VirtualBox Manager using the rule: host IP 127.0.0.1 and host port 2222 mapped to Guest Port 22

<br></br>
![Configure adapter](lab5/Screenshot%202023-09-16%20154651.png)

2. Install tasksel and openssh-server
<br></br>
![tasksel](lab5/Screenshot%202023-09-16%20154811.png)
<br></br>
![openssh-server](lab5/Screenshot%202023-09-16%20154847.png)

3. Starting the ssh service on the ubuntu VM
<br></br>
![ubuntu ssh](lab5/Screenshot%202023-09-16%20155101.png)

4. SSH into the Ubuntu VM from the hostOS using Putty:
<br></br>
![putty ssh](lab5/Screenshot%202023-09-16%20155143.png)
<br></br>
![putty ssh](lab5/Screenshot%202023-09-16%20155218.png)

5. Terminate the SSH service:
<br></br>
![terminate](lab5/Screenshot%202023-09-16%20155314.png)

### Section 2: Setting up an Application Load Balancer

1. The following function is used to create 2 EC2 instances in two different availability zones of ap-southeast-1. The reason ap-southeast-1 was used instead of ap-southeast-2 was due to the limit in VPCUs on ap-southeast-2 which did not allow for any new EC2 instances to be created on the region at the time of attempting this lab. 

```
def launch_ec2_instances():
	# Create a security group
	response = ec2.create_security_group(
		GroupName=f"{student_number}-sg",
		Description="security group for development environment"
	)
	security_group_id = response['GroupId']

	# Authorize inbound SSH traffic for the security group
	ec2.authorize_security_group_ingress(
		GroupId=security_group_id,
		IpProtocol="tcp",
		FromPort=22,
		ToPort=22,
		CidrIp="0.0.0.0/0"
	)
	
	# Create a key pair and save the private key to a file
	response = ec2.create_key_pair(KeyName=f"{student_number}-key")
	private_key = response['KeyMaterial']
	private_key_file = f"{student_number}-key.pem"
	
	# Allow writing to the private key file
	os.chmod(private_key_file, 0o666)
	with open(private_key_file, 'w') as key_file:
		key_file.write(private_key)
	# Set the correct permissions for the private key file
	os.chmod(private_key_file, 0o400)
	# Copy the private key file to ~/.ssh directory
	ssh_directory = os.path.expanduser("~/.ssh")
	if not os.path.exists(ssh_directory):
		os.makedirs(ssh_directory)

	shutil.copy(private_key_file, ssh_directory)

	availability_zones = ["ap-southeast-1a", "ap-southeast-1b"]

	for i, az in enumerate(availability_zones):
		instance_name = f"{student_number}-{az}"
		
		instance_params = {
		    'ImageId': 'ami-0df7a207adb9748c7',  
		    'InstanceType': 't2.micro',  
		    'KeyName': f"{student_number}-key",
		    'SecurityGroupIds' : [security_group_id], 
		    'MinCount': 1,
		    'MaxCount': 1,
		    'Placement': {'AvailabilityZone': az},
		    'TagSpecifications': [
		        {
		            'ResourceType': 'instance',
		            'Tags': [{'Key': 'Name', 'Value': instance_name}]
		        }
		    ]
		}

		# Launch an EC2 instance
		response = ec2.run_instances(**instance_params)

		instance_id = response['Instances'][0]['InstanceId']

		# Wait for the instance to be up and running
		ec2.get_waiter('instance_running').wait(InstanceIds=[instance_id])

		# Describe the instance to get its public IP address
		response = ec2.describe_instances(InstanceIds=[instance_id])
		public_ip_address = response['Reservations'][0]['Instances'][0]['PublicIpAddress']

		print(f"Instance {i+1} created successfully in Availability Zone {az} with Public IP: {public_ip_address}")
```
The created EC2 instances can be observed below. Note that the highlighted public IP addresses and availability zones in the AWS console correspond to the terminal output. 
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105046.png)
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105108.png)
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105138.png)
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105206.png)

2. The code below creates an application load balancer. 
    a. The code creates the load balancer and specifies the two region subnets retreived from step 1. 
    b. The code creates a listener with a default rule Protocol: HTTP and Port 80 forwarding on to the target group
    c. The code creates a target group using the VPC from step 1
    d. The code registers the two EC2 instances from step 1 as targets
```
def create_load_balancer():
	vpc_id = 'vpc-02806703abdc316d0'
	security_group_id = 'sg-0021774194b407020'
	subnet_ids = ['subnet-080783bde78702ba9', 'subnet-0da033b36a320696f']
	
	response = elb.create_load_balancer(
		Name='22489437-LoadBalancer',
		Subnets=subnet_ids,
		SecurityGroups=[security_group_id],
		Scheme='internet-facing',  
		Tags=[
		    {
		        'Key': 'Name',
		        'Value': '22489437-LoadBalancer'
		    },
		]
	) 
	
	load_balancer_arn = response['LoadBalancers'][0]['LoadBalancerArn']
	print(f"Load Balancer ARN: {load_balancer_arn}")
	
	# Create a listener for HTTP traffic (Port 80)
	response = elb.create_listener(
		DefaultActions=[
		    {
		        'Type': 'fixed-response',
		        'FixedResponseConfig': {
		            'ContentType': 'text/plain',
		            'StatusCode': '200',
		            'MessageBody': 'OK',
		        },
		    },
		],
		LoadBalancerArn=load_balancer_arn,
		Port=80,
		Protocol='HTTP',
	)

	listener_arn = response['Listeners'][0]['ListenerArn']
	print(f"Listener ARN: {listener_arn}")
	
	# Create a target group
	response = elb.create_target_group(
		Name='22489437-target-group',
		Protocol='HTTP',
		Port=80,
		VpcId=vpc_id,
		TargetType='instance',
	)

	# Get the ARN of the target group
	target_group_arn = response['TargetGroups'][0]['TargetGroupArn']

	# Print the target group ARN
	print(f"Target Group ARN: {target_group_arn}")
	
	instance_1_id = 'i-01624737c61ac9b4d'
	instance_2_id = 'i-0e105acc6d5603f70'

	# Register the instances in the target group
	elb.register_targets(
		TargetGroupArn=target_group_arn,
		Targets=[
		    {'Id': instance_1_id},
		    {'Id': instance_2_id},
		]
	)

	# Print registration status
	print("Targets registered successfully.")
```

The following screenshots show the output of running the code as well as the results in the AWS terminal.

<br></br>
![LB](lab5/Screenshot%202023-09-17%20113549.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114706.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114720.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114733.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114802.png)

3. In this step, we will SSH into each of the instances created in step 1 and install Apache2. Screenshots showing this process for one of the EC2 instances have been attached:

<br></br>
![LB](lab5/Screenshot%202023-09-17%20115049.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20115143.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20115721.png)

4. In this step we will edit the `/var/www/html/index.html` file to report the instance name and availability zone. 
<br></br>
![VI](lab5/Screenshot%202023-09-17%20124033.png)
<br></br>
![VI](lab5/Screenshot%202023-09-17%20124338.png)

5. By refreshing the page repeatedly, we can access both EC2 instances
<br></br>
![ec2](lab5/Screenshot%202023-09-17%20124351.png)
<br></br>
![ec2](lab5/Screenshot%202023-09-17%20124359.png)