# Lab Report 5 - 9

*Author*: Joo Kai Tay (22489437)

## Lab 5: Networking

### Section 1: Configure inbound IP on VM
1. Configure the network adapted in VirtualBox Manager using the rule: host IP 127.0.0.1 and host port 2222 mapped to Guest Port 22

<br></br>
![Configure adapter](lab5/Screenshot%202023-09-16%20154651.png)

2. Install tasksel and openssh-server
<br></br>
![tasksel](lab5/Screenshot%202023-09-16%20154811.png)
<br></br>
![openssh-server](lab5/Screenshot%202023-09-16%20154847.png)

3. Starting the ssh service on the ubuntu VM
<br></br>
![ubuntu ssh](lab5/Screenshot%202023-09-16%20155101.png)

4. SSH into the Ubuntu VM from the hostOS using Putty:
<br></br>
![putty ssh](lab5/Screenshot%202023-09-16%20155143.png)
<br></br>
![putty ssh](lab5/Screenshot%202023-09-16%20155218.png)

5. Terminate the SSH service:
<br></br>
![terminate](lab5/Screenshot%202023-09-16%20155314.png)

### Section 2: Setting up an Application Load Balancer

1. The following function is used to create 2 EC2 instances in two different availability zones of ap-southeast-1. The reason ap-southeast-1 was used instead of ap-southeast-2 was due to the limit in VPCUs on ap-southeast-2 which did not allow for any new EC2 instances to be created on the region at the time of attempting this lab. 

```
def launch_ec2_instances():
	# Create a security group
	response = ec2.create_security_group(
		GroupName=f"{student_number}-sg",
		Description="security group for development environment"
	)
	security_group_id = response['GroupId']

	# Authorize inbound SSH traffic for the security group
	ec2.authorize_security_group_ingress(
		GroupId=security_group_id,
		IpProtocol="tcp",
		FromPort=22,
		ToPort=22,
		CidrIp="0.0.0.0/0"
	)
	
	# Create a key pair and save the private key to a file
	response = ec2.create_key_pair(KeyName=f"{student_number}-key")
	private_key = response['KeyMaterial']
	private_key_file = f"{student_number}-key.pem"
	
	# Allow writing to the private key file
	os.chmod(private_key_file, 0o666)
	with open(private_key_file, 'w') as key_file:
		key_file.write(private_key)
	# Set the correct permissions for the private key file
	os.chmod(private_key_file, 0o400)
	# Copy the private key file to ~/.ssh directory
	ssh_directory = os.path.expanduser("~/.ssh")
	if not os.path.exists(ssh_directory):
		os.makedirs(ssh_directory)

	shutil.copy(private_key_file, ssh_directory)

	availability_zones = ["ap-southeast-1a", "ap-southeast-1b"]

	for i, az in enumerate(availability_zones):
		instance_name = f"{student_number}-{az}"
		
		instance_params = {
		    'ImageId': 'ami-0df7a207adb9748c7',  
		    'InstanceType': 't2.micro',  
		    'KeyName': f"{student_number}-key",
		    'SecurityGroupIds' : [security_group_id], 
		    'MinCount': 1,
		    'MaxCount': 1,
		    'Placement': {'AvailabilityZone': az},
		    'TagSpecifications': [
		        {
		            'ResourceType': 'instance',
		            'Tags': [{'Key': 'Name', 'Value': instance_name}]
		        }
		    ]
		}

		# Launch an EC2 instance
		response = ec2.run_instances(**instance_params)

		instance_id = response['Instances'][0]['InstanceId']

		# Wait for the instance to be up and running
		ec2.get_waiter('instance_running').wait(InstanceIds=[instance_id])

		# Describe the instance to get its public IP address
		response = ec2.describe_instances(InstanceIds=[instance_id])
		public_ip_address = response['Reservations'][0]['Instances'][0]['PublicIpAddress']

		print(f"Instance {i+1} created successfully in Availability Zone {az} with Public IP: {public_ip_address}")
```
The created EC2 instances can be observed below. Note that the highlighted public IP addresses and availability zones in the AWS console correspond to the terminal output. 
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105046.png)
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105108.png)
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105138.png)
<br></br>
![EC2](lab5/Screenshot%202023-09-17%20105206.png)

2. The code below creates an application load balancer. 
    a. The code creates the load balancer and specifies the two region subnets retreived from step 1. 
    b. The code creates a listener with a default rule Protocol: HTTP and Port 80 forwarding on to the target group
    c. The code creates a target group using the VPC from step 1
    d. The code registers the two EC2 instances from step 1 as targets
```
def create_load_balancer():
	vpc_id = 'vpc-02806703abdc316d0'
	security_group_id = 'sg-0021774194b407020'
	subnet_ids = ['subnet-080783bde78702ba9', 'subnet-0da033b36a320696f']
	
	response = elb.create_load_balancer(
		Name='22489437-LoadBalancer',
		Subnets=subnet_ids,
		SecurityGroups=[security_group_id],
		Scheme='internet-facing',  
		Tags=[
		    {
		        'Key': 'Name',
		        'Value': '22489437-LoadBalancer'
		    },
		]
	) 
	
	load_balancer_arn = response['LoadBalancers'][0]['LoadBalancerArn']
	print(f"Load Balancer ARN: {load_balancer_arn}")

	# Create a target group
	response = elb.create_target_group(
		Name='22489437-target-group',
		Protocol='HTTP',
        Port=80,
        VpcId=vpc_id,
        TargetType='instance'
    )
	
    # Get the ARN of the target group
	target_group_arn = response['TargetGroups'][0]['TargetGroupArn']
	print(f"Target Group ARN: {target_group_arn}")

	# Create a listener for HTTP traffic (Port 80)
	response = elb.create_listener(
        DefaultActions=[
            {
                'Type': 'forward',
                'TargetGroupArn': target_group_arn,
            },
        ],
        LoadBalancerArn=load_balancer_arn,
        Port=80,
        Protocol='HTTP',
    )

	listener_arn = response['Listeners'][0]['ListenerArn']
	print(f"Listener ARN: {listener_arn}")
	
	instance_1_id = 'i-01624737c61ac9b4d'
	instance_2_id = 'i-0e105acc6d5603f70'

	# Register the instances in the target group
	elb.register_targets(
		TargetGroupArn=target_group_arn,
		Targets=[
		    {'Id': instance_1_id},
		    {'Id': instance_2_id},
		]
	)

	# Print registration status
	print("Targets registered successfully.")
```

The following screenshots show the output of running the code as well as the results in the AWS terminal.

<br></br>
![LB](lab5/Screenshot%202023-09-17%20113549.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114706.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114720.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114733.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20114802.png)

3. In this step, we will SSH into each of the instances created in step 1 and install Apache2. Screenshots showing this process for one of the EC2 instances have been attached:

<br></br>
![LB](lab5/Screenshot%202023-09-17%20115049.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20115143.png)
<br></br>
![LB](lab5/Screenshot%202023-09-17%20115721.png)

4. In this step we will edit the `/var/www/html/index.html` file to report the instance name and availability zone. 
<br></br>
![VI](lab5/Screenshot%202023-09-17%20124033.png)
<br></br>
![VI](lab5/Screenshot%202023-09-17%20124338.png)

5. By refreshing the page repeatedly, we can access both EC2 instances
<br></br>
![ec2](lab5/Screenshot%202023-09-17%20124351.png)
<br></br>
![ec2](lab5/Screenshot%202023-09-17%20124359.png)

## Lab 6: Networking

### Section 1: Create an EC2 Instance

1. The code below was used to create an EC2 instance on ap-southeast-2c. For the lab this week, there was available capacity on ap-southeast-2 so there was no need to create the instance on another region. The AMI provided in lab 2 `ami-d38a4ab1` had a heavily outdated version of python and other utilities that are not compatible with modern programs, therefore an updated AMI was selected instead `ami-0310483fb2b488153`.

![ec2](lab6/Screenshot%202023-09-23%20084621.png)

```
def launch_ec2_instances():
	# Create a security group
	response = ec2.create_security_group(
		GroupName=f"{student_number}-sg",
		Description="security group for development environment"
	)
	security_group_id = response['GroupId']

	# Authorize inbound SSH traffic for the security group
	ec2.authorize_security_group_ingress(
		GroupId=security_group_id,
		IpProtocol="tcp",
		FromPort=22,
		ToPort=22,
		CidrIp="0.0.0.0/0"
	)
	
	ec2.authorize_security_group_ingress(
		GroupId=security_group_id,
		IpProtocol="tcp",
		FromPort=80,
		ToPort=80,
		CidrIp="0.0.0.0/0"
	)
	
	# Create a key pair and save the private key to a file
	response = ec2.create_key_pair(KeyName=f"{student_number}-key")
	private_key = response['KeyMaterial']
	private_key_file = f"{student_number}-key.pem"
	
	# Allow writing to the private key file
	os.chmod(private_key_file, 0o666)
	with open(private_key_file, 'w') as key_file:
		key_file.write(private_key)
	# Set the correct permissions for the private key file
	os.chmod(private_key_file, 0o400)
	# Copy the private key file to ~/.ssh directory
	ssh_directory = os.path.expanduser("~/.ssh")
	if not os.path.exists(ssh_directory):
		os.makedirs(ssh_directory)

	shutil.copy(private_key_file, ssh_directory)

	availability_zones = ["ap-southeast-2b", "ap-southeast-2c"]

	for i, az in enumerate(availability_zones):
		instance_name = f"{student_number}-{az}"
		
		instance_params = {
		    'ImageId': 'ami-0310483fb2b488153',  
		    'InstanceType': 't2.micro',  
		    'KeyName': f"{student_number}-key",
		    'SecurityGroupIds' : [security_group_id], 
		    'MinCount': 1,
		    'MaxCount': 1,
		    'Placement': {'AvailabilityZone': az},
		    'TagSpecifications': [
		        {
		            'ResourceType': 'instance',
		            'Tags': [{'Key': 'Name', 'Value': instance_name}]
		        }
		    ]
		}

		# Launch an EC2 instance
		response = ec2.run_instances(**instance_params)

		instance_id = response['Instances'][0]['InstanceId']

		# Wait for the instance to be up and running
		ec2.get_waiter('instance_running').wait(InstanceIds=[instance_id])

		# Describe the instance to get its public IP address
		response = ec2.describe_instances(InstanceIds=[instance_id])
		public_ip_address = response['Reservations'][0]['Instances'][0]['PublicIpAddress']

		print(f"Instance {i+1} created successfully in Availability Zone {az} with Public IP: {public_ip_address}")
```

![ec2](lab6/Screenshot%202023-09-23%20084642.png)

2. Using the private key obtained and public IP address obtained from step 1, SSH into the EC2 instance and install the Python 3 virtual environment package.

![ec2](lab6/Screenshot%202023-09-23%20084735.png)

![ec2](lab6/Screenshot%202023-09-23%20085139.png)

![ec2](lab6/Screenshot%202023-09-23%20085220.png)

![ec2](lab6/Screenshot%202023-09-23%20085949.png)

3. Creating a directory with path `/opt/wwc/mysites` and setting up the virtual environment.

![ec2](lab6/Screenshot%202023-09-23%20090113.png)

![ec2](lab6/Screenshot%202023-09-23%20090202.png)

4. A Django project is a collection of configurations and apps for a particular website. In this step we install Django and create a new Django app named polls.
	- `lab`: The configuration directory
	- `polls`: The directory containing the app
	- `manage.py`: The command line utility that lets us interact with the new app

![ec2](lab6/Screenshot%202023-09-23%20090235.png)

![ec2](lab6/Screenshot%202023-09-23%20090309.png)

### Section 2: Install and Congigure Nginx

1. Installing and configuring nginx:
	- Nginx is a popular open-source web server software that can also be used as a reverse proxy, load balancer, mail proxy, and HTTP cache. 
	- The configuration file is edited to tell Nginx to pass requests to the backend server running on the same machine 127.0.0.1 at port 8000.

![ec2](lab6/Screenshot%202023-09-23%20090326.png)

![ec2](lab6/Screenshot%202023-09-23%20090638.png)

![ec2](lab6/Screenshot%202023-09-23%20090700.png)

2. Restarting Nginx so that the changes from step 1 take effect:

![ec2](lab6/Screenshot%202023-09-23%20090723.png)

3. Using the command `python3 manage.py runserver 8000` to start Djangoâ€™s development web server at port 8000.

![ec2](lab6/Screenshot%202023-09-23%20090754.png)

4. Trying the access the public IP address of the EC2 instance results in an error:

![ec2](lab6/Screenshot%202023-09-23%20090856.png)

![ec2](lab6/Screenshot%202023-09-23%20161507.png)

### Section 3 Change the code

1. Editing `polls/views.py`
	- Thsi code creates a simple view that returns an HTTP response with the text "Hello, world." when it's called.

![ec2](lab6/Screenshot%202023-09-23%20093018.png)

2. Edit `polls/urls.py`
	- This code defines a URL pattern for this view in the urls.py file, so that Django knows which view to call for a given URL.

![ec2](lab6/Screenshot%202023-09-23%20093046.png)

3. Edit `lab/urls.py`
	- The code configures the URL patterns for the Django project. 

![ec2](lab6/Screenshot%202023-09-23%20093139.png)

4. Running the application and getting `Hello, world`

![ec2](lab6/Screenshot%202023-09-23%20093201.png)

![ec2](lab6/Screenshot%202023-09-23%20093451.png)

### Step 4: Adding an application load balance (ALB)

1. The code below creates an application load balancer, specifies the region subnet where the EC2 instance resides, creates a listener with a default rule Protocol: HTTP and Port 80 forwarding.

```
def create_load_balancer():
	vpc_id = 'vpc-00da1b229d10a51b6'
	security_group_id = 'sg-0fb8992bd2473b7bc'
	subnet_ids = ['subnet-0c1878c6a739707b7', 'subnet-0102e73cd4ff52b52']
	
	response = elb.create_load_balancer(
		Name='22489437-LoadBalancer',
		Subnets=subnet_ids,
		SecurityGroups=[security_group_id],
		Scheme='internet-facing',  
		Tags=[
		    {
		        'Key': 'Name',
		        'Value': '22489437-LoadBalancer'
		    },
		]
	) 
	
	load_balancer_arn = response['LoadBalancers'][0]['LoadBalancerArn']
	print(f"Load Balancer ARN: {load_balancer_arn}")

	# Create a target group
	response = elb.create_target_group(
		Name='22489437-target-group',
		Protocol='HTTP',
        Port=80,
        VpcId=vpc_id,
        HealthCheckProtocol='HTTP',
        HealthCheckPort='80',
        HealthCheckPath='/polls/',
        HealthCheckIntervalSeconds=30,
        HealthCheckTimeoutSeconds=5,
        HealthyThresholdCount=5,
        UnhealthyThresholdCount=2,
        Matcher={
            'HttpCode': '200'
        },
        TargetType='instance'
    )
	
    # Get the ARN of the target group
	target_group_arn = response['TargetGroups'][0]['TargetGroupArn']
	print(f"Target Group ARN: {target_group_arn}")

	# Create a listener for HTTP traffic (Port 80)
	response = elb.create_listener(
        DefaultActions=[
            {
                'Type': 'forward',
                'TargetGroupArn': target_group_arn,
            },
        ],
        LoadBalancerArn=load_balancer_arn,
        Port=80,
        Protocol='HTTP',
    )

	listener_arn = response['Listeners'][0]['ListenerArn']
	print(f"Listener ARN: {listener_arn}")
	
	
	instance_1_id = 'i-0164b69ac55068896'

	# Register the instances in the target group
	elb.register_targets(
		TargetGroupArn=target_group_arn,
		Targets=[
		    {'Id': instance_1_id},
		]
	)

	# Print registration status
	print("Targets registered successfully.")
```

![ec2](lab6/Screenshot%202023-09-23%20104033.png)

![ec2](lab6/Screenshot%202023-09-23%20104738.png)

2. Viewing the health check on the `/polls/` page

![ec2](lab6/Screenshot%202023-09-23%20170440.png)

3. Accessing the site using the url:

![ec2](lab6/Screenshot%202023-09-23%20105140.png)